A. 子树树上莫队
现在有一棵树，有n个节点，节点有点权，每次询问一个子树内的不重复数个数。
1<=n,q<=10^5，1<=点权<=10^9。
这个题显然比较trivial嘛...先把点权离散一下，然后一遍dfs搞出dfs序，那么一个子树就对应dfs序上一段，所以我们就可以在dfs序上莫队，开一个数组记一下每个数的出现次数。

B. 路径树上莫队
现在有一棵树，有n个节点，节点有点权，每次询问一条路径上的不重复数个数。
1<=n,q<=10^5，1<=点权<=10^9。
莫队用不了了？我们重新定义一个dfs序！
我们在开始访问和结束访问一个点的时候都记一下时间戳，我们设开始访问的时间为st，结束访问的时间为ed。
我们假设要询问一条路径a-b，设lca为p=lca(a,b)。不妨设st[a]<=st[b]（否则交换一下）。
当p=a时，这应该是一个比较简单的情形：a-b是一段父子链。
我们考虑这个新dfs序上[st[a],st[b]]的点，我们可以发现，a-b上的点被算了一遍，其他点都被算了2遍或0遍！那么我们统计的时候注意一下就可以了。
当p≠a时，我们也要一样统计[ed[a],st[b]]的点（从ed[a]开始为保证a不会被排除掉），但是这回lca会被重复统计，所以要另外算一下。